% -----------------------------------------------------------------------------
% Load control memory file
control_mm = ...
    memmapfile('_Control.dat', ...
    'Format', {...
        'int32' double([1 1]) 'is_terminated'; ...
        'int32' double([1 1]) 'header_size'; ...
        'uint64' double([1 1]) 'timestamp'; ...
        'int32' double([1 1]) 'plot_threshold'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', false);

% -----------------------------------------------------------------------------
% Load reader memory map file for raw data
raw_mm_header = ...
    memmapfile('_Raw.dat', ...
    'Format', {...
        'int64' double([1 1]) 'max_size_bytes'; ...
        'int64' double([1 1]) 'element_size_bytes'; ...
        'int64' double([1 1]) 'write_head'; ...
        'uint64' double([1 1]) 'start_time'; ...
        'single' double([1 2]) 'sensor_origin'; ...
        'uint64' double([1 1]) 'rotation_time_msec'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', false);
% ---
raw_end_index = int64(raw_mm_header.Data(1).max_size_bytes / raw_mm_header.Data(1).element_size_bytes);
raw_read_head = 1;
raw_write_head = 1;
raw_read_block_bounds = [[0, 0]; [0, 0]];
% ---
raw_mm_data = ...
    memmapfile('_Raw.dat', ...
    'Format', {...
        'uint64' double([1 1]) 'timestamp'; ...
        'single' double([1 1]) 'range'; ...
        'single' double([1 1]) 'azimuth'; ...
        'single' double([1 1]) 'speed'; ...
        'single' double([1 1]) 'intensity'; ...
        }, ...
    'Offset', control_mm.Data(1).header_size, ...
    'Repeat', raw_end_index, ...
    'Writable', false);

% -----------------------------------------------------------------------------
% Load writer memory map file for outgoing clutter data
cluttermap_mm_header = ...
    memmapfile('_ClutterMap.dat', ...
    'Format', {...
        'int64' double([1 1]) 'max_size_bytes'; ...
        'int64' double([1 1]) 'element_size_bytes'; ...
        'int64' double([1 1]) 'write_head'; ...
        'uint64' double([1 1]) 'start_time'; ...
        'single' double([1 2]) 'sensor_origin'; ...
        'uint64' double([1 1]) 'rotation_time_msec'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', true);
% ---
cluttermap_end_index = int64(cluttermap_mm_header.Data(1).max_size_bytes / cluttermap_mm_header.Data(1).element_size_bytes);
cluttermap_write_head = 1;
cluttermap_write_block_bounds = [[0, 0]; [0, 0]];
% ---
cluttermap_mm_data = ...
    memmapfile('_ClutterMap.dat', ...
    'Format', {...
        'single' double([1 cluttermap_end_index]) 'latitude'; ...
        'single' double([1 cluttermap_end_index]) 'longitude'; ...
        'uint32' double([1 cluttermap_end_index]) 'intensity'; ...
        }, ...
    'Offset', control_mm.Data(1).header_size, ...
    'Repeat', 1, ...
    'Writable', true);

% -----------------------------------------------------------------------------
% Load writer memory map file for outgoing plots data
plots_mm_header = ...
    memmapfile('_Plots.dat', ...
    'Format', {...
        'int64' double([1 1]) 'max_size_bytes'; ...
        'int64' double([1 1]) 'element_size_bytes'; ...
        'int64' double([1 1]) 'write_head'; ...
        'uint64' double([1 1]) 'start_time'; ...
        'single' double([1 2]) 'sensor_origin'; ...
        'uint64' double([1 1]) 'rotation_time_msec'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', true);
% ---
plots_end_index = int64(plots_mm_header.Data(1).max_size_bytes / plots_mm_header.Data(1).element_size_bytes);
plots_write_head = 1;
plots_write_block_bounds = [[0, 0]; [0, 0]];
% ---
plots_data = zeros([2, raw_end_index]);
plots_mm_data = ...
    memmapfile('_Plots.dat', ...
    'Format', {...
        'uint64' double([1 plots_end_index]) 'timestamp'; ...
        'single' double([1 plots_end_index]) 'latitude'; ...
        'single' double([1 plots_end_index]) 'longitude'; ...
        'single' double([1 plots_end_index]) 'range'; ...
        'single' double([1 plots_end_index]) 'azimuth'; ...
        'single' double([1 plots_end_index]) 'speed'; ...
        'int32' double([1 plots_end_index]) 'type'; ...
        }, ...
    'Offset', control_mm.Data(1).header_size, ...
    'Repeat', 1, ...
    'Writable', true);

% -----------------------------------------------------------------------------
% Preset common parameters and structures
interpreted_data = zeros([7, raw_end_index]);
is_terminated = control_mm.Data(1).is_terminated;
origin_latitude = raw_mm_header.Data(1).sensor_origin(1);
origin_longitude = raw_mm_header.Data(1).sensor_origin(2);
[r1, r2, w1, w2] = deal(0, 0, 0, 0);

% -----------------------------------------------------------------------------
% Primary processing loop
while ~is_terminated
    % Terminate the primary processing loop if the requisite control flag is set
    if control_mm.Data(1).is_terminated
        disp('Matlab process ended.');
        is_terminated = true;
        break
    end

    % Determine the last write index of the raw struct data
    raw_write_head = int64((raw_mm_header.Data(1).write_head / raw_mm_header.Data(1).element_size_bytes) + 1);
    % If no new data, sleep for 100ms and then try another run of the loop
    if raw_read_head == raw_write_head
        pause(0.1)
        continue
    end

    % Set up the read blocks for the incoming data, splitting the read in two if the buffer wraps
    if raw_read_head < raw_write_head
        raw_read_block_bounds = int64([[raw_read_head, raw_write_head]; [1, 1]]);
    else
        raw_read_block_bounds = int64([[raw_read_head, raw_end_index]; [1, raw_write_head]]);
    end

    % Parse the blocks of incoming data into clutter and plots
    for raw_read_block_index = 1:2
        r1 = raw_read_block_bounds(raw_read_block_index, 1);
        r2 = raw_read_block_bounds(raw_read_block_index, 2);
        % STAGE 1: Incoming Data to Clutter (for test only)
        if (~control_mm.Data(1).is_terminated) & (r1 ~= r2)
            read_range = r1:r2;
            % [General] Read the original timestamp
            interpreted_data(DATA.TIMESTAMP, read_range) = arrayfun(@(x) ...
                uint64(x.timestamp), ...
                raw_mm_data.Data(read_range, 1));
            % [General] Range azimuth to latitude/longitude
            [interpreted_data(DATA.LATITUDE, read_range) interpreted_data(DATA.LONGITUDE, read_range)] = arrayfun(@(x) ...
                razeltoll(origin_latitude, origin_longitude, x.range, x.azimuth, 0), ...
                raw_mm_data.Data(read_range, 1));
            % [General] Read the original range (for subsequent use)
            interpreted_data(DATA.RANGE, read_range) = arrayfun(@(x) ...
                single(x.range), ...
                raw_mm_data.Data(read_range, 1));
            % [General] Read the original azimuth (for subsequent use)
            interpreted_data(DATA.AZIMUTH, read_range) = arrayfun(@(x) ...
                single(x.azimuth), ...
                raw_mm_data.Data(read_range, 1));
            % [General] Read the speed
            interpreted_data(DATA.SPEED, read_range) = arrayfun(@(x) ...
                single(x.speed), ...
                raw_mm_data.Data(read_range, 1));
            % [General] Read the clutter intensity
            interpreted_data(DATA.INTENSITY, read_range) = arrayfun(@(x) ...
                single(x.intensity), ...
                raw_mm_data.Data(read_range, 1));
            % Determine the write blocks to allow for full write, wrapping around if necessary,
            % NOTE: Will skip if the range exceeds the current buffer max
            if r2 - r1 > cluttermap_end_index
                disp("Over max.");
                continue;
            elseif cluttermap_write_head + (r2 - r1) < cluttermap_end_index
                cluttermap_write_block_bounds = int64([[cluttermap_write_head, cluttermap_write_head + (r2 - r1)]; [1, 1]]);
            else
                cluttermap_write_block_bounds = int64([[cluttermap_write_head, cluttermap_end_index]; [1, cluttermap_write_head + (r2 - r1) - cluttermap_end_index]]);
            end

            % Write the plot blocks to the mirrored memory map
            for cluttermap_write_block_index = 1:2
                w1 = cluttermap_write_block_bounds(cluttermap_write_block_index, 1);
                w2 = cluttermap_write_block_bounds(cluttermap_write_block_index, 2);
                % Write block if it contains data to write and the the loop is not terminated
                if ~control_mm.Data(1).is_terminated & (w1 ~= w2)
                    cluttermap_write_range = w1:w2;
                    cluttermap_split_read_range = r1 + (0:(w2 - w1));
                    cluttermap_mm_data.Data.latitude(cluttermap_write_range) = interpreted_data(DATA.LATITUDE, cluttermap_split_read_range);
                    cluttermap_mm_data.Data.longitude(cluttermap_write_range) = interpreted_data(DATA.LONGITUDE, cluttermap_split_read_range);
                    cluttermap_mm_data.Data.intensity(cluttermap_write_range) = int32(interpreted_data(DATA.INTENSITY, cluttermap_split_read_range));
                    cluttermap_write_head = mod(cluttermap_write_head + (w2 - w1), cluttermap_end_index) + 1;
                    cluttermap_mm_header.Data(1).write_head = cluttermap_write_head;
                end

            end

            raw_read_head = raw_read_block_bounds(raw_read_block_index, 2);

        end

        % STAGE 2: Clutter to Plots using split clutter block (for test only)
        if (~control_mm.Data(1).is_terminated) & (r1 ~= r2)

            for cluttermap_write_block_index = 1:2
                w1 = cluttermap_write_block_bounds(cluttermap_write_block_index, 1);
                w2 = cluttermap_write_block_bounds(cluttermap_write_block_index, 2);
                % Parse block if it contains data and the the loop is not terminated
                if ~control_mm.Data(1).is_terminated & (w1 ~= w2)
                    cluttermap_write_range = w1:w2;
                    cluttermap_split_read_range = r1 + (0:(w2 - w1));
                    threshold_filter = int32(interpreted_data(DATA.INTENSITY, cluttermap_split_read_range)) >= control_mm.Data(1).plot_threshold;
                    num_new_plots = nnz(threshold_filter);
                    % Parse block if it contains data to write and the the loop is not terminated
                    if num_new_plots > 0
                        plots_read_range = 1:num_new_plots;
                        split_interpreted_data = interpreted_data(:, cluttermap_split_read_range);
                        plots_data(1:6, plots_read_range) = split_interpreted_data(1:6, threshold_filter);
                        % Specify a plot type
                        plots_data(PLOT.TYPE, plots_read_range) = arrayfun(@(x) ...
                            (x <= 20) + (x < 18) + (x < 16), ...
                            split_interpreted_data(DATA.INTENSITY, threshold_filter));

                        % Determine the write blocks to allow for full write, wrapping around if necessary
                        if plots_write_head + (num_new_plots - 1) < plots_end_index
                            plots_write_block_bounds = int64([[plots_write_head, plots_write_head + (num_new_plots - 1)]; [1, 1]]);
                        else
                            plots_write_block_bounds = int64([[plots_write_head, plots_end_index]; [1, plots_write_head + (num_new_plots - 1) - plots_end_index]]);
                        end

                        % Write the plot blocks to the mirrored memory map
                        for write_block_index = 1:2
                            w1 = plots_write_block_bounds(write_block_index, 1);
                            w2 = plots_write_block_bounds(write_block_index, 2);
                            % Write block if it contains data to write and the the loop is not terminated
                            if ~control_mm.Data(1).is_terminated & (w1 ~= w2)
                                plots_write_range = w1:w2;
                                plots_split_read_range = 1 + (0:(w2 - w1));
                                plots_mm_data.Data.timestamp(plots_write_range) = uint64(plots_data(PLOT.TIMESTAMP, plots_split_read_range));
                                plots_mm_data.Data.latitude(plots_write_range) = single(plots_data(PLOT.LATITUDE, plots_split_read_range));
                                plots_mm_data.Data.longitude(plots_write_range) = single(plots_data(PLOT.LONGITUDE, plots_split_read_range));
                                plots_mm_data.Data.range(plots_write_range) = uint32(plots_data(PLOT.RANGE, plots_split_read_range));
                                plots_mm_data.Data.azimuth(plots_write_range) = single(plots_data(PLOT.AZIMUTH, plots_split_read_range));
                                plots_mm_data.Data.speed(plots_write_range) = single(plots_data(PLOT.SPEED, plots_split_read_range));
                                plots_mm_data.Data.type(plots_write_range) = uint32(plots_data(PLOT.TYPE, plots_split_read_range));
                                plots_write_head = mod(plots_write_head + (w2 - w1), plots_end_index) + 1;
                                plots_mm_header.Data(1).write_head = plots_write_head;
                            end

                        end

                    end

                end

            end

        end

    end

end

% -----------------------------------------------------------------------------
