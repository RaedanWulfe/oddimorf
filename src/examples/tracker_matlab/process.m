% -----------------------------------------------------------------------------
% Load control memory file
control_mm = ...
    memmapfile('_Control.dat', ...
    'Format', {...
        'int32' double([1 1]) 'is_terminated'; ...
        'int32' double([1 1]) 'header_size'; ...
        'uint64' double([1 1]) 'timestamp'; ...
        'int32' double([1 1]) 'required_detections'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', false);

% -----------------------------------------------------------------------------
% Load reader memory map file for plots data
plots_mm_header = ...
    memmapfile('_Plots.dat', ...
    'Format', {...
        'int64' double([1 1]) 'max_size_bytes'; ...
        'int64' double([1 1]) 'element_size_bytes'; ...
        'int64' double([1 1]) 'write_head'; ...
        'uint64' double([1 1]) 'start_time'; ...
        'single' double([1 2]) 'sensor_origin'; ...
        'uint64' double([1 1]) 'rotation_time_msec'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', false);
% ---
plots_end_index = int64(plots_mm_header.Data(1).max_size_bytes / plots_mm_header.Data(1).element_size_bytes);
plots_read_head = 1;
plots_write_head = 1;
plots_read_block_bounds = [[0, 0]; [0, 0]];
% ---
plots_mm_data = ...
    memmapfile('_Plots.dat', ...
    'Format', {...
        'uint64' double([1 1]) 'timestamp'; ...
        'single' double([1 1]) 'latitude'; ...
        'single' double([1 1]) 'longitude'; ...
        'single' double([1 1]) 'range'; ...
        'single' double([1 1]) 'azimuth'; ...
        'single' double([1 1]) 'speed'; ...
        'int32' double([1 1]) 'type'; ...
        }, ...
    'Offset', control_mm.Data(1).header_size, ...
    'Repeat', plots_end_index, ...
    'Writable', false);

% -----------------------------------------------------------------------------
% Load writer memory map file for outgoing tracks data
tracks_mm_header = ...
    memmapfile('_Tracks.dat', ...
    'Format', {...
        'int64' double([1 1]) 'max_size_bytes'; ...
        'int64' double([1 1]) 'element_size_bytes'; ...
        'int64' double([1 1]) 'write_head'; ...
        'uint64' double([1 1]) 'start_time'; ...
        'single' double([1 2]) 'sensor_origin'; ...
        'uint64' double([1 1]) 'rotation_time_msec'; ...
        }, ...
    'Repeat', 1, ...
    'Writable', true);
% ---
tracks_end_index = int64(tracks_mm_header.Data(1).max_size_bytes / tracks_mm_header.Data(1).element_size_bytes);
tracks_write_head = 1;
tracks_write_block_bounds = [[0, 0]; [0, 0]];
% ---
tracks_mm_data = ...
    memmapfile('_Tracks.dat', ...
    'Format', {...
        'uint8' double([24 tracks_end_index]) 'time'; ...
        'uint8' double([5 tracks_end_index]) 'identifier'; ...
        'single' double([1 tracks_end_index]) 'latitude'; ...
        'single' double([1 tracks_end_index]) 'longitude'; ...
        'single' double([1 tracks_end_index]) 'bearing'; ...
        'single' double([1 tracks_end_index]) 'speed'; ...
        'uint32' double([1 tracks_end_index]) 'type'; ...
        'uint8' double([254 tracks_end_index]) 'info'; ...
        }, ...
    'Offset', control_mm.Data(1).header_size, ...
    'Repeat', 1, ...
    'Writable', true);

% -----------------------------------------------------------------------------
% Preset common parameters and structures
interpreted_data = zeros([12, plots_end_index * 16]);
viable_data = zeros([12, plots_end_index]);
new_data = zeros(size(viable_data));
all_times = zeros([1, plots_end_index]);
[min_time, max_time] = deal(0, 0);
[min_time, max_time] = deal(0, 0);
[min_ranges, max_ranges] = deal(cell(size(all_times)), cell(size(all_times)));
[min_azimuths, max_azimuths] = deal(min_ranges, max_ranges);
[lower_min_azimuths, lower_max_azimuths] = deal(min_azimuths, max_azimuths);
[upper_min_azimuths, upper_max_azimuths] = deal(min_azimuths, max_azimuths);
time_filter = zeros(size(all_times));
type_filter = cell(size(all_times));
range_filter = cell(size(all_times));
azimuth_filter = cell(size(all_times));
range_azimuth_window_match = cell(size(all_times));
track_data = zeros([12, 1]);
tracks_list_max = 1E04 - 1;
tracks = zeros([int32(TRACK.PLOTS_END), tracks_list_max]);
tracks_head = 0;
is_terminated = control_mm.Data(1).is_terminated;
origin_latitude = plots_mm_header.Data(1).sensor_origin(1);
origin_longitude = plots_mm_header.Data(1).sensor_origin(2);
search_window_time_offset_msec = 200;
rotation_time_msec = uint64(plots_mm_header.Data(1).rotation_time_msec);
rotation_time_sec = single(rotation_time_msec * 1E-3);
track_number = 1;
plot_sequence = 1;
[r1, r2] = deal(0, 0);

% -----------------------------------------------------------------------------
% Primary processing loop
while ~is_terminated
    % Terminate the primary processing loop if the requisite control flag is set
    if control_mm.Data(1).is_terminated
        disp('Matlab process ended.');
        is_terminated = true;
        break
    end

    % Determine the last write index of the plots struct data
    plots_write_head = int64((plots_mm_header.Data(1).write_head / plots_mm_header.Data(1).element_size_bytes) + 1);
    % If no new data, sleep for 100ms and then try another run of the loop
    if plots_read_head == plots_write_head
        pause(0.1)
        continue
    end

    required_detections = uint32(control_mm.Data(1).required_detections);

    % Set up the read blocks for the plots data, splitting the read in two if the buffer wraps
    if plots_read_head < plots_write_head
        plots_read_block_bounds = int64([[plots_read_head, plots_write_head]; [1, 1]]);
    else
        plots_read_block_bounds = int64([[plots_read_head, plots_end_index]; [1, plots_write_head]]);
    end

    % Interpret data to determine if tracks can be formed.
    for plots_read_block_index = 1:2
        r1 = plots_read_block_bounds(plots_read_block_index, 1);
        r2 = plots_read_block_bounds(plots_read_block_index, 2);
        % STAGE 1: Parse the blocks of plots data into predictive window boundaries in range, azimuth and time
        if (~control_mm.Data(1).is_terminated) & (r1 ~= r2)
            read_range = r1:r2;
            % [Time] Read the plot timestamp
            interpreted_data(DATA.TIMESTAMP, read_range) = arrayfun(@(x) ...
                uint64(x.timestamp), ...
                plots_mm_data.Data(read_range, 1));
            % [General] Unique identifier
            interpreted_data(DATA.PLOT_ID, read_range) = plot_sequence + (0:r2 - r1);
            plot_sequence = plot_sequence + (r2 - r1);
            % [General] Read the plot type specification
            interpreted_data(DATA.TYPE, read_range) = arrayfun(@(x) ...
                uint32(x.type), ...
                plots_mm_data.Data(read_range, 1));
            % [General] Read the plot latitude
            interpreted_data(DATA.LATITUDE, read_range) = arrayfun(@(x) ...
                single(x.latitude), ...
                plots_mm_data.Data(read_range, 1));
            % [General] Read the plot longitude
            interpreted_data(DATA.LONGITUDE, read_range) = arrayfun(@(x) ...
                single(x.longitude), ...
                plots_mm_data.Data(read_range, 1));
            % [General] Read the plot speed
            interpreted_data(DATA.SPEED, read_range) = arrayfun(@(x) ...
                single(x.speed), ...
                plots_mm_data.Data(read_range, 1));
            % [Range] Read the plot range
            interpreted_data(DATA.RANGE, read_range) = arrayfun(@(x) ...
                int32(x.range), ...
                plots_mm_data.Data(read_range, 1));
            % [Range] Determine the minimum search window range
            interpreted_data(DATA.WINDOW_MIN_RANGE, read_range) = arrayfun(@(x) ...
                int32(x.range - rotation_time_sec * x.speed), ...
                plots_mm_data.Data(read_range, 1));
            % [Range] Determine the maximum search window range
            interpreted_data(DATA.WINDOW_MAX_RANGE, read_range) = arrayfun(@(x) ...
                int32(x.range + rotation_time_sec * x.speed), ...
                plots_mm_data.Data(read_range, 1));
            % [Azimuth] Read the plot azimuth
            interpreted_data(DATA.AZIMUTH, read_range) = arrayfun(@(x) ...
                single(x.azimuth), ...
                plots_mm_data.Data(read_range, 1));
            % [Azimuth] Determine the minimum search window azimuth
            interpreted_data(DATA.WINDOW_MIN_AZIMUTH, read_range) = arrayfun(@(x) ...
                round(x.azimuth - rad2deg(tan(rotation_time_sec * x.speed / x.range))), ...
                plots_mm_data.Data(read_range, 1));
            % [Azimuth] Determine the maximum search window azimuth
            interpreted_data(DATA.WINDOW_MAX_AZIMUTH, read_range) = arrayfun(@(x) ...
                round(x.azimuth + rad2deg(tan(rotation_time_sec * x.speed / x.range))), ...
                plots_mm_data.Data(read_range, 1));

            plots_read_head = plots_read_block_bounds(plots_read_block_index, 2);

            % % STAGE 2: Check if new plots fall within the predicted time range of entries in active data
            % if (~control_mm.Data(1).is_terminated) & (r1 ~= r2)
            new_data = interpreted_data(:, read_range);

            [min_time, max_time] = deal(...
                min(new_data(DATA.TIMESTAMP, :)) - (rotation_time_msec + search_window_time_offset_msec), ...
                max(new_data(DATA.TIMESTAMP, :)) - (rotation_time_msec - search_window_time_offset_msec));
            all_times = interpreted_data(DATA.TIMESTAMP, :);
            time_filter = find((all_times >= min_time) & (all_times <= max_time));

            viable_data = interpreted_data(:, time_filter);

            if (~isempty(viable_data))

                [min_ranges, max_ranges] = deal(new_data(DATA.WINDOW_MIN_RANGE, :), new_data(DATA.WINDOW_MAX_RANGE, :));
                range_filter = arrayfun(@(x) ...
                    find((x >= min_ranges) & (x <= max_ranges)), ...
                    viable_data(7, :), ...
                    'UniformOutput', false);

                [min_azimuths, max_azimuths] = deal(new_data(DATA.WINDOW_MIN_AZIMUTH, :), new_data(DATA.WINDOW_MAX_AZIMUTH, :));
                [lower_min_azimuths, lower_max_azimuths] = deal(min_azimuths - 360, max_azimuths - 360);
                [upper_min_azimuths, upper_max_azimuths] = deal(min_azimuths + 360, max_azimuths + 360);

                azimuth_filter = arrayfun(@(x) ...
                    find(...
                    ((x >= 0) & (x < 360) & (x >= min_azimuths) & (x <= max_azimuths)) | ...
                    ((x < 5) & (x >= lower_min_azimuths) & (x <= lower_max_azimuths)) | ...
                    ((x >= 355) & (x >= upper_min_azimuths) & (x <= upper_max_azimuths)), 10), ...
                    viable_data(DATA.AZIMUTH, :), ...
                    'UniformOutput', false);

                for idx = 1:length(range_filter)

                    range_azimuth_window_match = intersect(range_filter{idx}, azimuth_filter{idx});

                    if ~isempty(range_azimuth_window_match)

                        plot_id_0 = viable_data(DATA.PLOT_ID, idx);

                        for match_idx = 1:length(range_azimuth_window_match)

                            track_data = new_data(:, range_azimuth_window_match(match_idx));

                            if (track_data(DATA.TYPE) <= 2)

                                if ismember(viable_data(DATA.PLOT_ID, idx), tracks(TRACK.PLOTS_START, :))

                                    for track_idx = find(tracks(TRACK.PLOTS_START, :) == viable_data(DATA.PLOT_ID, idx), 1)
                                        [bearing, ~] = llstobearing(...
                                            tracks(TRACK.LATITUDE, track_idx), tracks(TRACK.LONGITUDE, track_idx), 0, ...
                                            track_data(DATA.LATITUDE), track_data(DATA.LONGITUDE), 0);

                                        tracks(TRACK.LAST_UPDATED, track_idx) = track_data(DATA.TIMESTAMP);
                                        tracks(TRACK.LATITUDE, track_idx) = track_data(DATA.LATITUDE);
                                        tracks(TRACK.LONGITUDE, track_idx) = track_data(DATA.LONGITUDE);
                                        tracks(TRACK.TYPE, track_idx) = track_data(DATA.SPEED) < 40;
                                        tracks(TRACK.SPEED, track_idx) = track_data(DATA.SPEED);
                                        tracks(TRACK.BEARING, track_idx) = round(bearing);
                                        tracks(TRACK.DETECTIONS, track_idx) = tracks(TRACK.DETECTIONS, track_idx) + 1;
                                        tracks(TRACK.WINDOW_MIN_RANGE, track_idx) = track_data(DATA.WINDOW_MIN_RANGE);
                                        tracks(TRACK.WINDOW_MAX_RANGE, track_idx) = track_data(DATA.WINDOW_MAX_RANGE);
                                        tracks(TRACK.WINDOW_MIN_AZIMUTH, track_idx) = track_data(DATA.WINDOW_MIN_AZIMUTH);
                                        tracks(TRACK.WINDOW_MAX_AZIMUTH, track_idx) = track_data(DATA.WINDOW_MAX_AZIMUTH);
                                        tracks(uint32(TRACK.PLOTS_START + 1):uint32(TRACK.PLOTS_END), track_idx) = ...
                                            tracks(uint32(TRACK.PLOTS_START):uint32(TRACK.PLOTS_END - 1), track_idx);
                                        tracks(TRACK.PLOTS_START, track_idx) = track_data(DATA.PLOT_ID);
                                        tracks(TRACK.REQUIRES_REFRESH, track_idx) = tracks(TRACK.DETECTIONS, track_idx) >= required_detections;
                                    end

                                else
                                    tracks_head = mod(tracks_head, tracks_list_max) + 1;
                                    tracks(TRACK.LAST_UPDATED, tracks_head) = track_data(DATA.TIMESTAMP);
                                    tracks(TRACK.LATITUDE, tracks_head) = track_data(DATA.LATITUDE);
                                    tracks(TRACK.LONGITUDE, tracks_head) = track_data(DATA.LONGITUDE);
                                    tracks(TRACK.TYPE, tracks_head) = track_data(DATA.SPEED) < 40;
                                    tracks(TRACK.SPEED, tracks_head) = track_data(DATA.SPEED);
                                    tracks(TRACK.BEARING, tracks_head) = 0;
                                    tracks(TRACK.DETECTIONS, tracks_head) = 2;
                                    tracks(TRACK.WINDOW_MIN_RANGE, tracks_head) = track_data(DATA.WINDOW_MIN_RANGE);
                                    tracks(TRACK.WINDOW_MAX_RANGE, tracks_head) = track_data(DATA.WINDOW_MAX_RANGE);
                                    tracks(TRACK.WINDOW_MIN_AZIMUTH, tracks_head) = track_data(DATA.WINDOW_MIN_AZIMUTH);
                                    tracks(TRACK.WINDOW_MAX_AZIMUTH, tracks_head) = track_data(DATA.WINDOW_MAX_AZIMUTH);
                                    tracks(uint32(TRACK.PLOTS_START):uint32(TRACK.PLOTS_END), tracks_head) = 0;
                                    tracks(TRACK.PLOTS_START + 1, tracks_head) = plot_id_0;
                                    tracks(TRACK.PLOTS_START, tracks_head) = track_data(DATA.PLOT_ID);
                                    tracks(TRACK.REQUIRES_REFRESH, tracks_head) = false;
                                end

                            end

                        end

                    end

                end

            end

        end

    end

    % STAGE 3: Print out viable tracks to output.
    for idx = find(tracks(TRACK.REQUIRES_REFRESH, :) == true)

        % Parse block if it contains data and the the loop is not terminated
        tracks(TRACK.REQUIRES_REFRESH, idx) = false;
        tracks_mm_data.Data.time(1:24, tracks_write_head) = uint8(datestr(datetime('now', 'TimeZone', 'UTC'), 'yyyy-mm-ddTHH:MM:ss.FFFZ'));
        tracks_mm_data.Data.identifier(1:5, tracks_write_head) = uint8(num2str(idx, '%05.f'));
        tracks_mm_data.Data.latitude(1, tracks_write_head) = single(tracks(TRACK.LATITUDE, idx));
        tracks_mm_data.Data.longitude(1, tracks_write_head) = single(tracks(TRACK.LONGITUDE, idx));
        tracks_mm_data.Data.bearing(1, tracks_write_head) = single(tracks(TRACK.BEARING, idx));
        tracks_mm_data.Data.speed(1, tracks_write_head) = single(tracks(TRACK.SPEED, idx));
        tracks_mm_data.Data.type(1, tracks_write_head) = uint32(tracks(TRACK.TYPE, idx));
        tracks_mm_data.Data.info(1:254, tracks_write_head) = uint8(pad(strcat(...
            '<pre><em>INFO</em>', ...
            '<hr>WND.AZI&nbsp;', int2str(tracks(TRACK.WINDOW_MIN_RANGE, idx)), ' -&nbsp;', int2str(tracks(TRACK.WINDOW_MAX_RANGE, idx)), ' m', ...
            '<br>WND.RNG&nbsp;', int2str(tracks(TRACK.WINDOW_MIN_AZIMUTH, idx)), ' -&nbsp;', int2str(tracks(TRACK.WINDOW_MAX_AZIMUTH, idx)), '&#176;', ...
            '<br>QUALITY&nbsp;', int2str(min(tracks(TRACK.DETECTIONS, idx), 7)), ...
            '</pre>'), 254));
        tracks_write_head = mod(tracks_write_head, tracks_end_index);
        tracks_mm_header.Data(1).write_head = tracks_write_head;
        tracks_write_head = tracks_write_head + 1;

    end

end

% -----------------------------------------------------------------------------
